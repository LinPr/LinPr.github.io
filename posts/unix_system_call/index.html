<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unix_System_Call | Mr.LinPr Hugo Site</title>
<meta name=keywords content="linux"><meta name=description content="常用 Unix 函数总结 1. 文件操作 文件流操作 #include <stdio.h> 打开，关闭 FILE* fopen(const char* filename, const char* mode); int fclose(FILE* stream); 数据块读写，大小为 size * numb size_t fread(void *ptr, size_t size, size_t numb, FILE *stream); size_t fwrite(void *ptr, size_t size, size_t numb, FILE *stream); 格式化读，由format参数指定读的数据格式，由 ... 参数指定接收的容器 int fscanf(FILE *stream, const char *format, …); int fprintf(FILE *stream, const char *format, ...); int scanf(const char *format, …); int printf(const char *format, ...); //相当于fprintf(stdout,format,…); 从字符串中读取指定的格式 int sscanf(char *str, const char *format, …); int sprintf(char *str, const char *format, ."><meta name=author content="LinPr"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://LinPr.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://LinPr.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://LinPr.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://LinPr.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://LinPr.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Unix_System_Call"><meta property="og:description" content="常用 Unix 函数总结 1. 文件操作 文件流操作 #include <stdio.h> 打开，关闭 FILE* fopen(const char* filename, const char* mode); int fclose(FILE* stream); 数据块读写，大小为 size * numb size_t fread(void *ptr, size_t size, size_t numb, FILE *stream); size_t fwrite(void *ptr, size_t size, size_t numb, FILE *stream); 格式化读，由format参数指定读的数据格式，由 ... 参数指定接收的容器 int fscanf(FILE *stream, const char *format, …); int fprintf(FILE *stream, const char *format, ...); int scanf(const char *format, …); int printf(const char *format, ...); //相当于fprintf(stdout,format,…); 从字符串中读取指定的格式 int sscanf(char *str, const char *format, …); int sprintf(char *str, const char *format, ."><meta property="og:type" content="article"><meta property="og:url" content="https://LinPr.github.io/posts/unix_system_call/"><meta property="og:image" content="https://LinPr.github.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-09T12:08:15+08:00"><meta property="article:modified_time" content="2024-02-09T12:08:15+08:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://LinPr.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="Unix_System_Call"><meta name=twitter:description content="常用 Unix 函数总结 1. 文件操作 文件流操作 #include <stdio.h> 打开，关闭 FILE* fopen(const char* filename, const char* mode); int fclose(FILE* stream); 数据块读写，大小为 size * numb size_t fread(void *ptr, size_t size, size_t numb, FILE *stream); size_t fwrite(void *ptr, size_t size, size_t numb, FILE *stream); 格式化读，由format参数指定读的数据格式，由 ... 参数指定接收的容器 int fscanf(FILE *stream, const char *format, …); int fprintf(FILE *stream, const char *format, ...); int scanf(const char *format, …); int printf(const char *format, ...); //相当于fprintf(stdout,format,…); 从字符串中读取指定的格式 int sscanf(char *str, const char *format, …); int sprintf(char *str, const char *format, ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://LinPr.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Unix_System_Call","item":"https://LinPr.github.io/posts/unix_system_call/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unix_System_Call","name":"Unix_System_Call","description":"常用 Unix 函数总结 1. 文件操作 文件流操作 #include \u0026lt;stdio.h\u0026gt; 打开，关闭 FILE* fopen(const char* filename, const char* mode); int fclose(FILE* stream); 数据块读写，大小为 size * numb size_t fread(void *ptr, size_t size, size_t numb, FILE *stream); size_t fwrite(void *ptr, size_t size, size_t numb, FILE *stream); 格式化读，由format参数指定读的数据格式，由 ... 参数指定接收的容器 int fscanf(FILE *stream, const char *format, …); int fprintf(FILE *stream, const char *format, ...); int scanf(const char *format, …); int printf(const char *format, ...); //相当于fprintf(stdout,format,…); 从字符串中读取指定的格式 int sscanf(char *str, const char *format, …); int sprintf(char *str, const char *format, .","keywords":["linux"],"articleBody":"常用 Unix 函数总结 1. 文件操作 文件流操作 #include 打开，关闭 FILE* fopen(const char* filename, const char* mode); int fclose(FILE* stream); 数据块读写，大小为 size * numb size_t fread(void *ptr, size_t size, size_t numb, FILE *stream); size_t fwrite(void *ptr, size_t size, size_t numb, FILE *stream); 格式化读，由format参数指定读的数据格式，由 ... 参数指定接收的容器 int fscanf(FILE *stream, const char *format, …); int fprintf(FILE *stream, const char *format, ...); int scanf(const char *format, …); int printf(const char *format, ...); //相当于fprintf(stdout,format,…); 从字符串中读取指定的格式 int sscanf(char *str, const char *format, …); int sprintf(char *str, const char *format, ...); //eg:sprintf(buf,”the string is;%s”,str); 字符读写 int fgetc(FILE *stream); int fputc(int c, FILE *stream); int getc(FILE *stream);//等同于 fgetc(FILE* stream) int putc(int c, FILE *stream);//等同于 fputc(int c, FILE* stream) int getchar(void);//等同于 fgetc(stdin); int putchar(int c);//等同于 fputc(int c, stdout); 单行读写 char *fgets(char *s, int size, FILE *stream); int fputs(const char *s, FILE *stream); int puts(const char *s);//等同于 fputs(const char *s,stdout); char *gets(char *s);//等同于 fgets(const char *s, int size, stdin); 文件定位 int feof(FILE * stream); //通常的用法为while(!feof(fp)) int fseek(FILE *stream, long offset, int whence); //设置当前读写点到偏移whence 长度为offset处 long ftell(FILE *stream); //用来获得文件流当前的读写位置 void rewind(FILE *stream); //把文件流的读写位置移至文件开头 fseek(fp, 0, SEEK_SET); 文件权限 #include int chmod(const char* path, mode_t mode); 目录操作 获取，改变当前目录 #include //头文件 char *getcwd(char *buf, size_t size); //获取当前目录，相当于pwd命令 getcwd(NULL, 0); int chdir(const char *path); //修改当前目录，即切换目录，相当于cd命令 创建，删除 #include #include #include int mkdir(const char *pathname, mode_t mode); //创建目录,mode是目录权限 int rmdir(const char *pathname); //删除目录 其他操作 #include #include DIR *opendir(const char *name); //打开一个目录 struct dirent *readdir(DIR *dir); //读取目录的一项信息，并返回该项信息的结构体指针 void rewinddir(DIR *dir); //重新定位到目录文件的头部 void seekdir(DIR *dir,off_t offset);//用来设置目录流目前的读取位置 off_t telldir(DIR *dir); //返回目录流当前的读取位置 int closedir(DIR *dir); //关闭目录文件 #include #include #include int stat(const char *pathname, struct stat *buf); //获取文件状态 目录项 和 iNode节点\n目录项（只保存文件的最基本信息） struct dirent{ ino_t d_ino; //该文件的inode off_t d_off; //到下一个dirent的偏移 unsigned short d_reclen;//文件名长度 unsigned char d_type; //所指的文件类型 char d_name[256]; //文件名 }; iNode节点（保存文件的所有信息） #include #include DIR *opendir(const char *name); //打开一个目录 struct dirent *readdir(DIR *dir); //读取目录的一项信息，并返回该项信息的结构体指针 void rewinddir(DIR *dir); //重新定位到目录文件的头部 void seekdir(DIR *dir,off_t offset);//用来设置目录流目前的读取位置 off_t telldir(DIR *dir); //返回目录流当前的读取位置 int closedir(DIR *dir); //关闭目录文件 #include #include #include 文件描述符操作 打开，创建，读写，关闭 #include //头文件 #include #include int open(const char *pathname, int flags); //文件名 打开方式 int open(const char *pathname, int flags, mode_t mode);//文件名 打开方式 权限 int creat(const char *pathname, mode_t mode); //文件名 权限 //creat现在已经不常用了，它等价于 open(pathname,O_CREAT|O_TRUNC|O_WRONLY,mode); int close(int fd);//fd表示文件描述词,是先前由open或creat创建文件时的返回值。 读写 #include ssize_t read(int fd, void *buf, size_t count);//文件描述符 缓冲区 长度 ssize_t write(int fd, const void *buf, size_t count); 改变文件大小 #include int ftruncate(int fd, off_t length); 文件映射 void *mmap(void *adr, size_t len, int prot, int flag, int fd, off_t off); char *p; p = (char *)mmap(NULL,5,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); 文件定位（内核缓冲区） off_t lseek(int fd, off_t offset, int whence);//fd文件描述词 获取文件信息 #include #include #include int stat(const char *file_name, struct stat *buf); //文件名 stat结构体指针 int fstat(int fd, struct stat *buf); //文件描述词 stat结构体指针 文件描述符的复制 #include int dup(int oldfd); int dup2(int oldfd, int newfd); 2. 进程操作 进程属性 pid_t getpid(void); pid_t getppid(void); uid_t getuid(void); uid_t geteuid(void); gid_t getgid(void); gid_t getegid(void); pid_t fork(void); int execl(const char *path, const char *arg0, ... /*, (char *)0 */); int execv(const char *path, char *const argv[]); int execle(const char *path, const char *arg0, ... /*, (char *)0, char *const envp[] */); int execlp(const char *file, const char *arg0, ... /*, (char *)0 */); int execvp(const char *file, char *const argv[]); pid_t wait(int *stat_loc); pid_t waitpid(pid_t pid, int *stat_loc, int options); void exit(int status);//可以看出exit函数是由ISO C规定的 void _exit(int status;//_exit是一个Linux系统调用 void _Exit(int status);//_Exit是ISO C规定的库函数 pid_t getpgrp(void);//获取进程组ID pid_t getpgid(pid_t pid);//获取PID为pid的进程的进程组ID，如果pid为0，则获取本进程所属进程组ID int setpgid(pid_t pid, pid_t pgid);//将pid进程的进程组ID设置为pgid //如果pid为0，使用调用者的进程ID //如果pgid为0，则进程组ID和pid一致 pid_t setsid(void); //以当前进程为组长创建一个新会话 pid_t getsid(pid_t pid); //获取指定进程的会话id 进程间通信 匿名管道 #include FILE *popen(const char *command, const char *type); int pclose(FILE *stream); #include int pipe(int pipefd[2]); 有名管道 #include #include #include #include int mkfifo(const char *pathname, mode_t mode); int rename(const char *oldpath, const char *newpath); //重命名 int unlink(const char *path); //删除硬链接 int link(const char *oldpath, const char *newpath); //创建硬链接 //注意这里的newpath必须是文件名而不是目录名 XSI IPC \u003e\u003e ipcs \u003e\u003e ipcrm -m shmid 共享内存 #include #include #include key_t ftok(const char *pathname, int proj_id); //用file 生成key int shmget(key_t key, size_t size, int shmflg); //创建或者获取一个共享内存区段或者私有共享内存区,如果参数key的取值是宏 IPC_PRIVATE 共享内存段是私有的 void *shmat(int shmid, const void *shmaddr, int shmflg); //连接到一个共享内存区段 int shmdt(const void *shmaddr); int shmctl(int shmid, int cmd, struct shmid_ds *buf); //修改共享区段属性 使用 shmctl 可以用于对共享内存段执行多种操作。根据cmd参数的不同，可以执行不同的操作： IPC_STAT可以用来获取存储共享内存段信息的数据结构； IPC_SET可以用来修改共享内存段的所有者、所在组和权限； IPC_RMID可以用来从内核删除共享内存段，当删除时，无论此时有多少进程映射到共享内存段，它都会被标记为待删除，一旦被标记以后，就无法再建立映射了。当最后一个映射解除时，共享内存段就真正被移除。 信号量 int semget(key_t key, int nsems, int semflg); int semctl(int semid, int semnum, int cmd, ...); 在函数 semctl 中， semid参数是信号量的标识符，就是 semget 的返回值， semnum表示某个信号量值在信号量集合中的索引（范围从0开始） cmd参数表示要执行的操作： IPC_STAT表示要获取信号量状态，可变参数要设置为状态结构体的指针； IPC_SET表示要设置信号量状态，可变参数要设置为状态结构体的指针； IPC_RMID表示要删除信号量，不需要设置可变参数，注意和共享内存的删除不同，信号量是立即删除的； GETVAL表示获取置某个信号量值，可变参数传入数值 SETVAL表示设置某个信号量值，可变参数传入数值； GETALL和SETALL表示获取和设置信号量集合，可变参数传入一个短整型数组或者不写。 struct sembuf{ unsigned short sem_num; /* semaphore number */ short sem_op; /* semaphore operation */ short sem_flg; /* operation flags */ } int semop(int semid, struct sembuf *sops, size_t nsops); //这个由用户自己声明，用于取出信号量的属性时使用 union semun{ int val; //val for SETVAL struct semid_ds *buf; //buffer for IPC_STAT,IPC_SET unsigned short *arry; //Array for GETALL,SETALL } 消息队列 int msgget(key_t key, int msgflg); struct mymesg{ long mtype; char mtext[1]; }; int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); msgctl(msgid,IPC_RMID,NULL);//删除是即时的 信号 typedef void (*sighandler_t)(int); 注册信号方式1 sighandler_t signal(int signum, sighandler_t handler); struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; /* typedef struct {unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];} __sigset_t; typedef __sigset_t sigset_t; //sigset_t的本质就是一个位图，共有1024位 int sigemptyset(sigset_t *set); //初始化信号集，清0所有信号 int sigfillset(sigset_t *set); //初始化信号集，置1所有信号 int sigaddset(sigset_t *set, int signum); //增加信号 int sigdelset(sigset_t *set, int signum); //删除信号 int sigismember(const sigset_t *set, int signum); //检查信号处于信号集之中 */ int sa_flags; /* SA_SIGINFO 表示选择sa_sigaction而不是sa_handler作为回调函数 SA_RESETHAND 处理完捕获的信号以后，信号处理回归到默认，使用情况较少 SA_NODEFER 解除所有阻塞行为。特别地，执行信号处理流程可以处理同类信号传递，按照栈的方式执行。 SA_RESTART 让低速系统调用可以自动重启 */ void (*sa_restorer)(void); }; 注册信号方式2 int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); sigset_t pendingSet; int sigpending(\u0026pendingSet); //获取当前所有未决信号（已经产生没有递送的信号）的集合 使用系统调用 sigprocmask 可以实现全程阻塞的效果 int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); how SIG_BLOCK 新的屏蔽字是set和当前屏蔽字的并集 SIG_UNBLOCK 新的屏蔽字是set的补集和当前屏蔽字的交集 SIG_SETMASK 新的屏蔽字是set /* sigemptyset(\u0026mask); sigaddset(\u0026mask,SIGINT); int ret = sigprocmask(SIG_BLOCK,\u0026mask,NULL); ret = sigprocmask(SIG_UNBLOCK,\u0026mask,NULL); */ sigprocmask 可以和 sigpending 之间配合使用 系统调用 int kill(pid_t pid, int sig); int pause(void); //来阻塞一个进程，直到某个信号被递送时，进程会解除阻塞 /* #if 1 sigprocmask(SIG_UNBLOCK,\u0026mask,NULL); pause();//无法就绪 #else sigset_t waitset; sigemptyset(\u0026waitset); sigsuspend(\u0026waitset);//使用sigsuspend会捕获临界区当中的信号 #endif */ 3. 时钟 #include 间隔定时器，类似于相机自动拍摄，当设置拍摄第一张照片的时间后，每间隔一段相同的时间连续自动拍摄（溢出） struct itimerval { struct timeval it_interval; /* Interval for periodic timer */ struct timeval it_value; /* Time until next expiration */ }; int getitimer(int which, struct itimerval *curr_value); int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); ITIMER_REAL 会记录真实的时间（也就是时钟时间），当时间到时，会产生一个SIGALRM信号。 ITIMER_VIRTUAL 会记录用户态模式下的CPU时间，当时间到的时候，会产生一个SIGVTALRM信号。 ITIMER_PROF 会记录用户态以及内核态的CPU时间，当时间到的时候，会产生一个SIGPROF信号。 安装信号捕捉handler函数捕捉信号，并且打印时间即可 相关结构体 struct timeval { time_t tv_sec; /* seconds */ suseconds_t tv_usec; /* microseconds */ }; struct timezone { int tz_minuteswest; /* minutes west of Greenwich */ int tz_dsttime; /* type of DST correction */ }; int gettimeofday(struct timeval *tv, struct timezone *tz); int settimeofday(const struct timeval *tv, const struct timezone *tz); #include time_t time(time_t *tloc); struct tm { int tm_sec; /* Seconds (0-60) */ int tm_min; /* Minutes (0-59) */ int tm_hour; /* Hours (0-23) */ int tm_mday; /* Day of the month (1-31) */ int tm_mon; /* Month (0-11) */ int tm_year; /* Year - 1900 */ int tm_wday; /* Day of the week (0-6, Sunday = 0) */ int tm_yday; /* Day in the year (0-365, 1 Jan = 0) */ int tm_isdst; /* Daylight saving time */ }; struct tm *gmtime(const time_t *timep); struct tm *localtime(const time_t *timep); time_t mktime(struct tm *tm); ctime(), gmtime() localtime() functions all take an argument of data type time_t, On success, gmtime() and localtime() return a pointer to a struct tm. On success, asctime() and ctime() return a pointer to a string. 4. 线程操作 错误处理 char *strerror(int errnum); #define STRERROR_CHECK(ret,msg) {if(ret!=0){fprintf(stderr, \"%s:%s\\n\", msg,strerror(ret));}} #define PERROR_CHECK(ret , error_val, fileName) { if(ret == error_val){ perror(fileName); return -1; }} 线程操作 查看线程状态 \u003e\u003e ps -elLf \u003e\u003e top -H 创建线程 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 获取线程ID pthread_t pthread_self(void); 线程退出 void pthread_exit(void *retval); 线程资源回收 int pthread_join(pthread_t thread, void **retval); 线程取消 int pthread_cancel(pthread_t thread); void pthread_testcancel(void) //设置cancelation point 线程资源清理 void pthread_cleanup_push(void (*routine)(void *), void *arg); void pthread_cleanup_pop(int execute); 互斥锁 pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER; int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr); int pthread_mutex_destroy(pthread_mutex_t *mutex); int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); 条件变量 pthread_cond_t cond = PTHREAD_COND_INITIALIZER; int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime); int pthread_cond_destroy(pthread_cond_t *cond); 5. 网络编程 地址信息转换 //man 7 ip 套接字二元组 /* Internet address. */ struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ /* struct in_addr { uint32_t s_addr; };*/ struct in_addr sin_addr; /* internet address */ } /* address in network byte order */ }; #include #include #include 字节序转换 // h:host\tn:net\tl:32bit s:16bit uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); 将IP地址转换成文本 const char *inet_ntop(int af, const void *src,char *dst, socklen_t size); // inet_ntop - convert IPv4 and IPv6 addresses from binary to text form 网络字节序\u003c-----\u003e点分十进制相互转换 int inet_aton(const char *cp, struct in_addr *inp); == in_addr_t inet_addr(const char *cp); char *inet_ntoa(struct in_addr in); //线程安全版本是inet_atop inet_ptoa 获取某域名的IP相关信息 #include struct hostent *gethostbyname(const char *name); //传入参数 struct hostent { char *h_name; /* official name of host */ char **h_aliases; /* alias list */ int h_addrtype; /* host address type */ int h_length; /* length of address */ char **h_addr_list; /* list of addresses */ } 套接字编程 #include 创建套接字 //domain AF_INET --\u003e IPv4 AF_INET6 --\u003e IPv6 //type SOCK_STREAM --\u003e TCP SOCK_DGRAM --\u003e UDP //protocol IPPROTO_TCP --\u003e TCP IPPROTO_UDP --\u003eUDP int socket(int domain, int type, int protocol); TCP 客户端 1. int socket(int domain, int type, int protocol); 2. int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 3. ssize_t send(int sockfd, const void *buf, size_t len, int flags); ssize_t recv(int sockfd, void *buf, size_t len, int flags); 服务器 1. int socket(int domain, int type, int protocol); 2. int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 3. int listen(int sockfd, int backlog); 4. int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 5. ssize_t send(int sockfd, const void *buf, size_t len, int flags); ssize_t recv(int sockfd, void *buf, size_t len, int flags); UDP ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); epoll 1. 创建epoll文件对象 int epoll_create(int size); 2. 设置事件合集 struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ /*typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t;*/ }; int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event); 3. 等待事件 int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout); ","wordCount":"1703","inLanguage":"en","image":"https://LinPr.github.io/%3Cimage%20path/url%3E","datePublished":"2024-02-09T12:08:15+08:00","dateModified":"2024-02-09T12:08:15+08:00","author":{"@type":"Person","name":"LinPr"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://LinPr.github.io/posts/unix_system_call/"},"publisher":{"@type":"Organization","name":"Mr.LinPr Hugo Site","logo":{"@type":"ImageObject","url":"https://LinPr.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://LinPr.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://LinPr.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://LinPr.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://LinPr.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://LinPr.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://LinPr.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Unix_System_Call</h1><div class=post-meta><span title='2024-02-09 12:08:15 +0800 CST'>February 9, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1703 words&nbsp;·&nbsp;LinPr&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Unix_System_Call.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-文件操作>1. 文件操作</a><ul><li><a href=#文件流操作>文件流操作</a></li><li><a href=#目录操作>目录操作</a></li><li><a href=#文件描述符操作>文件描述符操作</a></li></ul></li><li><a href=#2-进程操作>2. 进程操作</a><ul><li><a href=#进程属性>进程属性</a></li><li><a href=#进程间通信>进程间通信</a></li></ul></li><li><a href=#3-时钟>3. 时钟</a></li><li><a href=#4-线程操作>4. 线程操作</a><ul><li><a href=#错误处理>错误处理</a></li><li><a href=#线程操作>线程操作</a></li><li><a href=#互斥锁>互斥锁</a></li><li><a href=#条件变量>条件变量</a></li></ul></li><li><a href=#5-网络编程>5. 网络编程</a><ul><li><a href=#地址信息转换>地址信息转换</a></li><li><a href=#套接字编程>套接字编程</a></li><li><a href=#epoll>epoll</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=常用-unix-函数总结>常用 Unix 函数总结<a hidden class=anchor aria-hidden=true href=#常用-unix-函数总结>#</a></h1><h2 id=1-文件操作>1. 文件操作<a hidden class=anchor aria-hidden=true href=#1-文件操作>#</a></h2><h3 id=文件流操作>文件流操作<a hidden class=anchor aria-hidden=true href=#文件流操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=err>打开，关闭</span>
</span></span><span class=line><span class=cl><span class=n>FILE</span><span class=o>*</span> <span class=nf>fopen</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>filename</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fclose</span><span class=p>(</span><span class=n>FILE</span><span class=o>*</span> <span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>数据块读写，大小为</span> <span class=n>size</span> <span class=o>*</span> <span class=n>numb</span>
</span></span><span class=line><span class=cl><span class=kt>size_t</span> <span class=nf>fread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>numb</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>size_t</span> <span class=nf>fwrite</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>numb</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>格式化读，由</span><span class=n>format参数指定读的数据格式</span><span class=err>，由</span> <span class=p>...</span> <span class=err>参数指定接收的容器</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fscanf</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=err>…</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fprintf</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>scanf</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=err>…</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>printf</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=c1>//相当于fprintf(stdout,format,…);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>从字符串中读取指定的格式</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sscanf</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=err>…</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sprintf</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>format</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=c1>//eg:sprintf(buf,”the string is;%s”,str);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>字符读写</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fgetc</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fputc</span><span class=p>(</span><span class=kt>int</span> <span class=n>c</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getc</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span><span class=c1>//等同于 fgetc(FILE* stream)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>putc</span><span class=p>(</span><span class=kt>int</span> <span class=n>c</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span><span class=c1>//等同于 fputc(int c, FILE* stream)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>getchar</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span><span class=c1>//等同于 fgetc(stdin);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>putchar</span><span class=p>(</span><span class=kt>int</span> <span class=n>c</span><span class=p>);</span><span class=c1>//等同于 fputc(int c, stdout);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>单行读写</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>fgets</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fputs</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>puts</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span><span class=c1>//等同于 fputs(const char *s,stdout);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=nf>gets</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span><span class=c1>//等同于 fgets(const char *s, int size, stdin);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>文件定位</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>feof</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span> <span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//通常的用法为while(!feof(fp))
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>fseek</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>,</span> <span class=kt>long</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>int</span> <span class=n>whence</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//设置当前读写点到偏移whence 长度为offset处
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>long</span> <span class=nf>ftell</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//用来获得文件流当前的读写位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>rewind</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//把文件流的读写位置移至文件开头 fseek(fp, 0, SEEK_SET);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>文件权限</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>chmod</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>path</span><span class=p>,</span> <span class=kt>mode_t</span> <span class=n>mode</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=目录操作>目录操作<a hidden class=anchor aria-hidden=true href=#目录操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>获取，改变当前目录</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt; //头文件</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>char</span> <span class=o>*</span><span class=nf>getcwd</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>);</span> <span class=c1>//获取当前目录，相当于pwd命令
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>getcwd</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>chdir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>);</span> <span class=c1>//修改当前目录，即切换目录，相当于cd命令
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>创建，删除</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>mkdir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>mode_t</span> <span class=n>mode</span><span class=p>);</span> <span class=c1>//创建目录,mode是目录权限
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>rmdir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>);</span> <span class=c1>//删除目录
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>其他操作</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dirent.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>DIR</span> <span class=o>*</span><span class=nf>opendir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span> <span class=c1>//打开一个目录
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=nf>readdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>);</span> <span class=c1>//读取目录的一项信息，并返回该项信息的结构体指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>rewinddir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>);</span> <span class=c1>//重新定位到目录文件的头部
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>seekdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>,</span><span class=kt>off_t</span> <span class=n>offset</span><span class=p>);</span><span class=c1>//用来设置目录流目前的读取位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>off_t</span> <span class=nf>telldir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>);</span> <span class=c1>//返回目录流当前的读取位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>closedir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>);</span> <span class=c1>//关闭目录文件
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>stat</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>buf</span><span class=p>);</span> <span class=c1>//获取文件状态
</span></span></span></code></pre></div><p>目录项 和 iNode节点</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>目录项（只保存文件的最基本信息）</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=kt>ino_t</span> <span class=n>d_ino</span><span class=p>;</span> <span class=c1>//该文件的inode
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>off_t</span> <span class=n>d_off</span><span class=p>;</span> <span class=c1>//到下一个dirent的偏移
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>d_reclen</span><span class=p>;</span><span class=c1>//文件名长度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>d_type</span><span class=p>;</span> <span class=c1>//所指的文件类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>d_name</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span> <span class=c1>//文件名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>iNode节点</span><span class=err>（保存文件的所有信息）</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dirent.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>DIR</span> <span class=o>*</span><span class=nf>opendir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span> <span class=c1>//打开一个目录
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=nf>readdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>);</span> <span class=c1>//读取目录的一项信息，并返回该项信息的结构体指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>rewinddir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>);</span> <span class=c1>//重新定位到目录文件的头部
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>seekdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>,</span><span class=kt>off_t</span> <span class=n>offset</span><span class=p>);</span><span class=c1>//用来设置目录流目前的读取位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>off_t</span> <span class=nf>telldir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>);</span> <span class=c1>//返回目录流当前的读取位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>closedir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span><span class=p>);</span> <span class=c1>//关闭目录文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span></code></pre></div><h3 id=文件描述符操作>文件描述符操作<a hidden class=anchor aria-hidden=true href=#文件描述符操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>打开，创建，读写，关闭</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt; //头文件</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>open</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span> <span class=c1>//文件名 打开方式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>open</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=kt>mode_t</span> <span class=n>mode</span><span class=p>);</span><span class=c1>//文件名 打开方式 权限
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>creat</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>mode_t</span> <span class=n>mode</span><span class=p>);</span> <span class=c1>//文件名 权限
</span></span></span><span class=line><span class=cl><span class=c1>//creat现在已经不常用了，它等价于
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>open</span><span class=p>(</span><span class=n>pathname</span><span class=p>,</span><span class=n>O_CREAT</span><span class=o>|</span><span class=n>O_TRUNC</span><span class=o>|</span><span class=n>O_WRONLY</span><span class=p>,</span><span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>close</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span><span class=c1>//fd表示文件描述词,是先前由open或creat创建文件时的返回值。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>读写</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>ssize_t</span> <span class=nf>read</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>count</span><span class=p>);</span><span class=c1>//文件描述符 缓冲区 长度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>ssize_t</span> <span class=nf>write</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>改变文件大小</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>ftruncate</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>文件映射</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mmap</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>adr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flag</span><span class=p>,</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>off</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span><span class=n>MAP_SHARED</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>文件定位（内核缓冲区）</span>
</span></span><span class=line><span class=cl><span class=kt>off_t</span> <span class=nf>lseek</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>int</span> <span class=n>whence</span><span class=p>);</span><span class=c1>//fd文件描述词
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>获取文件信息</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>stat</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file_name</span><span class=p>,</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>buf</span><span class=p>);</span> <span class=c1>//文件名 stat结构体指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>fstat</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>buf</span><span class=p>);</span> <span class=c1>//文件描述词 stat结构体指针
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>文件描述符的复制</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>dup</span><span class=p>(</span><span class=kt>int</span> <span class=n>oldfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>dup2</span><span class=p>(</span><span class=kt>int</span> <span class=n>oldfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>newfd</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=2-进程操作>2. 进程操作<a hidden class=anchor aria-hidden=true href=#2-进程操作>#</a></h2><h3 id=进程属性>进程属性<a hidden class=anchor aria-hidden=true href=#进程属性>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>getpid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>getppid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uid_t</span> <span class=nf>getuid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uid_t</span> <span class=nf>geteuid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>gid_t</span> <span class=nf>getgid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>gid_t</span> <span class=nf>getegid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execl</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg0</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/*, (char *)</span><span class=mi>0</span> <span class=err>*/</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execle</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg0</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/*, (char *)</span><span class=mi>0</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span>
</span></span><span class=line><span class=cl><span class=n>envp</span><span class=p>[]</span> <span class=err>*/</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execlp</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg0</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/*, (char *)</span><span class=mi>0</span> <span class=err>*/</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execvp</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>wait</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>stat_loc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>waitpid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>stat_loc</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>exit</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>);</span><span class=c1>//可以看出exit函数是由ISO C规定的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>_exit</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>;</span><span class=c1>//_exit是一个Linux系统调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>_Exit</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>);</span><span class=c1>//_Exit是ISO C规定的库函数
</span></span></span><span class=line><span class=cl><span class=c1></span>           
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>getpgrp</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span><span class=c1>//获取进程组ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>pid_t</span> <span class=nf>getpgid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>);</span><span class=c1>//获取PID为pid的进程的进程组ID，如果pid为0，则获取本进程所属进程组ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>setpgid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>pid_t</span> <span class=n>pgid</span><span class=p>);</span><span class=c1>//将pid进程的进程组ID设置为pgid
</span></span></span><span class=line><span class=cl><span class=c1>//如果pid为0，使用调用者的进程ID
</span></span></span><span class=line><span class=cl><span class=c1>//如果pgid为0，则进程组ID和pid一致
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>setsid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> <span class=c1>//以当前进程为组长创建一个新会话  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>pid_t</span> <span class=nf>getsid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>);</span> <span class=c1>//获取指定进程的会话id
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>           
</span></span></code></pre></div><h3 id=进程间通信>进程间通信<a hidden class=anchor aria-hidden=true href=#进程间通信>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>匿名管道</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>FILE</span> <span class=o>*</span><span class=nf>popen</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>command</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pclose</span><span class=p>(</span><span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>pipe</span><span class=p>(</span><span class=kt>int</span> <span class=n>pipefd</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>有名管道</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>mkfifo</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>mode_t</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>rename</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>oldpath</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>newpath</span><span class=p>);</span> <span class=c1>//重命名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>unlink</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>);</span> <span class=c1>//删除硬链接
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>link</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>oldpath</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>newpath</span><span class=p>);</span> <span class=c1>//创建硬链接
</span></span></span><span class=line><span class=cl><span class=c1>//注意这里的newpath必须是文件名而不是目录名
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>XSI</span> <span class=n>IPC</span>    
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;</span> <span class=n>ipcs</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;</span> <span class=n>ipcrm</span> <span class=o>-</span><span class=n>m</span> <span class=n>shmid</span>  
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl><span class=err>共享内存</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ipc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/shm.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>key_t</span> <span class=nf>ftok</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>proj_id</span><span class=p>);</span> <span class=c1>//用file 生成key
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>shmget</span><span class=p>(</span><span class=kt>key_t</span> <span class=n>key</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shmflg</span><span class=p>);</span> <span class=c1>//创建或者获取一个共享内存区段或者私有共享内存区,如果参数key的取值是宏 IPC_PRIVATE 共享内存段是私有的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=nf>shmat</span><span class=p>(</span><span class=kt>int</span> <span class=n>shmid</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>shmaddr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shmflg</span><span class=p>);</span> <span class=c1>//连接到一个共享内存区段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>shmdt</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>shmaddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>shmctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>shmid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>shmid_ds</span> <span class=o>*</span><span class=n>buf</span><span class=p>);</span> <span class=c1>//修改共享区段属性
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>使用</span> <span class=n>shmctl</span> <span class=err>可以用于对共享内存段执行多种操作。根据</span><span class=n>cmd参数的不同</span><span class=err>，可以执行不同的操作：</span>
</span></span><span class=line><span class=cl>           <span class=n>IPC_STAT可以用来获取存储共享内存段信息的数据结构</span><span class=err>；</span>
</span></span><span class=line><span class=cl>           <span class=n>IPC_SET可以用来修改共享内存段的所有者</span><span class=err>、所在组和权限；</span> 
</span></span><span class=line><span class=cl>           <span class=n>IPC_RMID可以用来从内核删除共享内存段</span><span class=err>，当删除时，无论此时有多少进程映射到共享内存段，它都会被标记为待删除，一旦被标记以后，就无法再建立映射了。当最后一个映射解除时，共享内存段就真正被移除。</span>
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>信号量</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>semget</span><span class=p>(</span><span class=kt>key_t</span> <span class=n>key</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nsems</span><span class=p>,</span> <span class=kt>int</span> <span class=n>semflg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>semctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>semid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>semnum</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=err>在函数</span> <span class=n>semctl</span> <span class=err>中，</span>
</span></span><span class=line><span class=cl>           <span class=n>semid参数是信号量的标识符</span><span class=err>，就是</span> <span class=n>semget</span> <span class=err>的返回值，</span>
</span></span><span class=line><span class=cl>           <span class=n>semnum表示某个信号量值在信号量集合中的索引</span><span class=err>（范围从</span><span class=mi>0</span><span class=err>开始）</span>
</span></span><span class=line><span class=cl>           <span class=n>cmd参数表示要执行的操作</span><span class=err>：</span>
</span></span><span class=line><span class=cl>           <span class=n>IPC_STAT表示要获取信号量状态</span><span class=err>，可变参数要设置为状态结构体的指针；</span>
</span></span><span class=line><span class=cl>           <span class=n>IPC_SET表示要设置信号量状态</span><span class=err>，可变参数要设置为状态结构体的指针；</span>
</span></span><span class=line><span class=cl>           <span class=n>IPC_RMID表示要删除信号量</span><span class=err>，不需要设置可变参数，注意和共享内存的删除不同，信号量是立即删除的；</span>
</span></span><span class=line><span class=cl>           <span class=n>GETVAL表示获取置某个信号量值</span><span class=err>，可变参数传入数值</span>
</span></span><span class=line><span class=cl>           <span class=n>SETVAL表示设置某个信号量值</span><span class=err>，可变参数传入数值；</span>
</span></span><span class=line><span class=cl>           <span class=n>GETALL和SETALL表示获取和设置信号量集合</span><span class=err>，可变参数传入一个短整型数组或者不写。</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sembuf</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>sem_num</span><span class=p>;</span> <span class=cm>/* semaphore number */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>sem_op</span><span class=p>;</span> <span class=cm>/* semaphore operation */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>sem_flg</span><span class=p>;</span> <span class=cm>/* operation flags */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>semop</span><span class=p>(</span><span class=kt>int</span> <span class=n>semid</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sembuf</span> <span class=o>*</span><span class=n>sops</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>nsops</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//这个由用户自己声明，用于取出信号量的属性时使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>union</span> <span class=n>semun</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span><span class=p>;</span> <span class=c1>//val for SETVAL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>semid_ds</span> <span class=o>*</span><span class=n>buf</span><span class=p>;</span> <span class=c1>//buffer for IPC_STAT,IPC_SET
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>short</span> <span class=o>*</span><span class=n>arry</span><span class=p>;</span> <span class=c1>//Array for GETALL,SETALL
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>           
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl><span class=err>消息队列</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>msgget</span><span class=p>(</span><span class=kt>key_t</span> <span class=n>key</span><span class=p>,</span> <span class=kt>int</span> <span class=n>msgflg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>mymesg</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>mtype</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>mtext</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>msgsnd</span><span class=p>(</span><span class=kt>int</span> <span class=n>msqid</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>msgp</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>msgsz</span><span class=p>,</span> <span class=kt>int</span> <span class=n>msgflg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>msgrcv</span><span class=p>(</span><span class=kt>int</span> <span class=n>msqid</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>msgp</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>msgsz</span><span class=p>,</span> <span class=kt>long</span> <span class=n>msgtyp</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>msgflg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>msgctl</span><span class=p>(</span><span class=n>msgid</span><span class=p>,</span><span class=n>IPC_RMID</span><span class=p>,</span><span class=nb>NULL</span><span class=p>);</span><span class=c1>//删除是即时的
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl><span class=err>信号</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=kt>sighandler_t</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err>注册信号方式</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kt>sighandler_t</span> <span class=nf>signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>,</span> <span class=kt>sighandler_t</span> <span class=n>handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sigaction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sa_handler</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sa_sigaction</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>siginfo_t</span> <span class=o>*</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>sigset_t</span> <span class=n>sa_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>        typedef struct
</span></span></span><span class=line><span class=cl><span class=cm>        {unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];} 
</span></span></span><span class=line><span class=cl><span class=cm>        __sigset_t;
</span></span></span><span class=line><span class=cl><span class=cm>        typedef __sigset_t sigset_t; //sigset_t的本质就是一个位图，共有1024位
</span></span></span><span class=line><span class=cl><span class=cm>        int sigemptyset(sigset_t *set); //初始化信号集，清0所有信号
</span></span></span><span class=line><span class=cl><span class=cm>        int sigfillset(sigset_t *set);  //初始化信号集，置1所有信号
</span></span></span><span class=line><span class=cl><span class=cm>        int sigaddset(sigset_t *set, int signum); //增加信号
</span></span></span><span class=line><span class=cl><span class=cm>        int sigdelset(sigset_t *set, int signum); //删除信号
</span></span></span><span class=line><span class=cl><span class=cm>        int sigismember(const sigset_t *set, int signum); //检查信号处于信号集之中
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sa_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    	SA_SIGINFO   表示选择sa_sigaction而不是sa_handler作为回调函数
</span></span></span><span class=line><span class=cl><span class=cm>        SA_RESETHAND 处理完捕获的信号以后，信号处理回归到默认，使用情况较少
</span></span></span><span class=line><span class=cl><span class=cm>        SA_NODEFER   解除所有阻塞行为。特别地，执行信号处理流程可以处理同类信号传递，按照栈的方式执行。
</span></span></span><span class=line><span class=cl><span class=cm>        SA_RESTART   让低速系统调用可以自动重启
</span></span></span><span class=line><span class=cl><span class=cm>	*/</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sa_restorer</span><span class=p>)(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=err>注册信号方式</span><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigaction</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sigaction</span> <span class=o>*</span><span class=n>act</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sigaction</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>oldact</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>sigset_t</span> <span class=n>pendingSet</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigpending</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pendingSet</span><span class=p>);</span> <span class=c1>//获取当前所有未决信号（已经产生没有递送的信号）的集合
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>使用系统调用</span> <span class=n>sigprocmask</span> <span class=err>可以实现全程阻塞的效果</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigprocmask</span><span class=p>(</span><span class=kt>int</span> <span class=n>how</span><span class=p>,</span> <span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>oldset</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>           	<span class=n>how</span> 
</span></span><span class=line><span class=cl>            <span class=n>SIG_BLOCK</span> <span class=err>新的屏蔽字是</span><span class=n>set和当前屏蔽字的并集</span>
</span></span><span class=line><span class=cl>            <span class=n>SIG_UNBLOCK</span> <span class=err>新的屏蔽字是</span><span class=n>set的补集和当前屏蔽字的交集</span>
</span></span><span class=line><span class=cl>            <span class=n>SIG_SETMASK</span> <span class=err>新的屏蔽字是</span><span class=n>set</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	sigemptyset(&amp;mask);
</span></span></span><span class=line><span class=cl><span class=cm>    sigaddset(&amp;mask,SIGINT);
</span></span></span><span class=line><span class=cl><span class=cm>    int ret = sigprocmask(SIG_BLOCK,&amp;mask,NULL);
</span></span></span><span class=line><span class=cl><span class=cm>    ret = sigprocmask(SIG_UNBLOCK,&amp;mask,NULL);
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=n>sigprocmask</span> <span class=err>可以和</span>  <span class=n>sigpending</span> <span class=err>之间配合使用</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl><span class=err>系统调用</span> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>kill</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sig</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pause</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>  <span class=c1>//来阻塞一个进程，直到某个信号被递送时，进程会解除阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	#if 1
</span></span></span><span class=line><span class=cl><span class=cm>        sigprocmask(SIG_UNBLOCK,&amp;mask,NULL);
</span></span></span><span class=line><span class=cl><span class=cm>        pause();//无法就绪
</span></span></span><span class=line><span class=cl><span class=cm>    #else
</span></span></span><span class=line><span class=cl><span class=cm>        sigset_t waitset;
</span></span></span><span class=line><span class=cl><span class=cm>        sigemptyset(&amp;waitset);
</span></span></span><span class=line><span class=cl><span class=cm>        sigsuspend(&amp;waitset);//使用sigsuspend会捕获临界区当中的信号
</span></span></span><span class=line><span class=cl><span class=cm>    #endif
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><h2 id=3-时钟>3. 时钟<a hidden class=anchor aria-hidden=true href=#3-时钟>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=err>间隔定时器，类似于相机自动拍摄，当设置拍摄第一张照片的时间后，每间隔一段相同的时间连续自动拍摄（溢出）</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>itimerval</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>timeval</span> <span class=n>it_interval</span><span class=p>;</span> <span class=cm>/* Interval for periodic timer */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>timeval</span> <span class=n>it_value</span><span class=p>;</span> <span class=cm>/* Time until next expiration */</span>  
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getitimer</span><span class=p>(</span><span class=kt>int</span> <span class=n>which</span><span class=p>,</span> <span class=k>struct</span> <span class=n>itimerval</span> <span class=o>*</span><span class=n>curr_value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setitimer</span><span class=p>(</span><span class=kt>int</span> <span class=n>which</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>itimerval</span> <span class=o>*</span><span class=n>new_value</span><span class=p>,</span> <span class=k>struct</span> <span class=n>itimerval</span> <span class=o>*</span><span class=n>old_value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ITIMER_REAL</span>    <span class=err>会记录真实的时间（也就是时钟时间），当时间到时，会产生一个</span><span class=n>SIGALRM信号</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=n>ITIMER_VIRTUAL</span> <span class=err>会记录用户态模式下的</span><span class=n>CPU时间</span><span class=err>，当时间到的时候，会产生一个</span><span class=n>SIGVTALRM信号</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=n>ITIMER_PROF</span>    <span class=err>会记录用户态以及内核态的</span><span class=n>CPU时间</span><span class=err>，当时间到的时候，会产生一个</span><span class=n>SIGPROF信号</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=err>安装信号捕捉</span><span class=n>handler函数捕捉信号</span><span class=err>，并且打印时间即可</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>相关结构体</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>timeval</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>time_t</span> <span class=n>tv_sec</span><span class=p>;</span> <span class=cm>/* seconds */</span>
</span></span><span class=line><span class=cl>    <span class=kt>suseconds_t</span> <span class=n>tv_usec</span><span class=p>;</span> <span class=cm>/* microseconds */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>timezone</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tz_minuteswest</span><span class=p>;</span>     <span class=cm>/* minutes west of Greenwich */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tz_dsttime</span><span class=p>;</span>         <span class=cm>/* type of DST correction */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>gettimeofday</span><span class=p>(</span><span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>tv</span><span class=p>,</span> <span class=k>struct</span> <span class=n>timezone</span> <span class=o>*</span><span class=n>tz</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>settimeofday</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>tv</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>timezone</span> <span class=o>*</span><span class=n>tz</span><span class=p>);</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>time_t</span> <span class=nf>time</span><span class=p>(</span><span class=kt>time_t</span> <span class=o>*</span><span class=n>tloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>tm</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_sec</span><span class=p>;</span>    <span class=cm>/* Seconds (0-60) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_min</span><span class=p>;</span>    <span class=cm>/* Minutes (0-59) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_hour</span><span class=p>;</span>   <span class=cm>/* Hours (0-23) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_mday</span><span class=p>;</span>   <span class=cm>/* Day of the month (1-31) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_mon</span><span class=p>;</span>    <span class=cm>/* Month (0-11) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_year</span><span class=p>;</span>   <span class=cm>/* Year - 1900 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_wday</span><span class=p>;</span>   <span class=cm>/* Day of the week (0-6, Sunday = 0) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_yday</span><span class=p>;</span>   <span class=cm>/* Day in the year (0-365, 1 Jan = 0) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tm_isdst</span><span class=p>;</span>  <span class=cm>/* Daylight saving time */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>tm</span> <span class=o>*</span><span class=nf>gmtime</span><span class=p>(</span><span class=k>const</span> <span class=kt>time_t</span> <span class=o>*</span><span class=n>timep</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>tm</span> <span class=o>*</span><span class=nf>localtime</span><span class=p>(</span><span class=k>const</span> <span class=kt>time_t</span> <span class=o>*</span><span class=n>timep</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>time_t</span> <span class=nf>mktime</span><span class=p>(</span><span class=k>struct</span> <span class=n>tm</span> <span class=o>*</span><span class=n>tm</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>ctime</span><span class=p>(),</span> <span class=nf>gmtime</span><span class=p>()</span> <span class=nf>localtime</span><span class=p>()</span> <span class=n>functions</span> <span class=n>all</span> <span class=n>take</span> <span class=n>an</span> <span class=n>argument</span> <span class=n>of</span> <span class=n>data</span> <span class=n>type</span>  <span class=kt>time_t</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>On</span> <span class=n>success</span><span class=p>,</span> <span class=nf>gmtime</span><span class=p>()</span> <span class=n>and</span> <span class=nf>localtime</span><span class=p>()</span> <span class=k>return</span> <span class=n>a</span> <span class=n>pointer</span> <span class=n>to</span> <span class=n>a</span> <span class=k>struct</span> <span class=n>tm</span><span class=p>.</span>
</span></span><span class=line><span class=cl>    <span class=n>On</span> <span class=n>success</span><span class=p>,</span> <span class=nf>asctime</span><span class=p>()</span> <span class=n>and</span> <span class=nf>ctime</span><span class=p>()</span> <span class=k>return</span> <span class=n>a</span> <span class=n>pointer</span> <span class=n>to</span> <span class=n>a</span> <span class=n>string</span><span class=p>.</span>
</span></span><span class=line><span class=cl>    
</span></span></code></pre></div><h2 id=4-线程操作>4. 线程操作<a hidden class=anchor aria-hidden=true href=#4-线程操作>#</a></h2><h3 id=错误处理>错误处理<a hidden class=anchor aria-hidden=true href=#错误处理>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>strerror</span><span class=p>(</span><span class=kt>int</span> <span class=n>errnum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#define STRERROR_CHECK(ret,msg) {if(ret!=0){fprintf(stderr, &#34;%s:%s\n&#34;, msg,strerror(ret));}}
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define PERROR_CHECK(ret , error_val, fileName) { if(ret == error_val){ perror(fileName); return -1; }}
</span></span></span></code></pre></div><h3 id=线程操作>线程操作<a hidden class=anchor aria-hidden=true href=#线程操作>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>查看线程状态</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;</span> <span class=n>ps</span> <span class=o>-</span><span class=n>elLf</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;</span> <span class=n>top</span> <span class=o>-</span><span class=n>H</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>创建线程</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_create</span><span class=p>(</span><span class=kt>pthread_t</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span> <span class=k>const</span> <span class=kt>pthread_attr_t</span> <span class=o>*</span><span class=n>attr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>									<span class=kt>void</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>start_routine</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>),</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>获取线程</span><span class=n>ID</span>
</span></span><span class=line><span class=cl><span class=kt>pthread_t</span> <span class=nf>pthread_self</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>线程退出</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pthread_exit</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>retval</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>线程资源回收</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_join</span><span class=p>(</span><span class=kt>pthread_t</span> <span class=kr>thread</span><span class=p>,</span> <span class=kt>void</span> <span class=o>**</span><span class=n>retval</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>线程取消</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cancel</span><span class=p>(</span><span class=kt>pthread_t</span> <span class=kr>thread</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pthread_testcancel</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>   <span class=c1>//设置cancelation point
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>线程资源清理</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pthread_cleanup_push</span><span class=p>(</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>routine</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>),</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pthread_cleanup_pop</span><span class=p>(</span><span class=kt>int</span> <span class=n>execute</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=互斥锁>互斥锁<a hidden class=anchor aria-hidden=true href=#互斥锁>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>fastmutex</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_init</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>,</span> <span class=k>const</span> <span class=kt>pthread_mutexattr_t</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>mutexattr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_destroy</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_trylock</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=条件变量>条件变量<a hidden class=anchor aria-hidden=true href=#条件变量>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>pthread_cond_t</span> <span class=n>cond</span> <span class=o>=</span> <span class=n>PTHREAD_COND_INITIALIZER</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cond_init</span><span class=p>(</span><span class=kt>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>,</span> <span class=kt>pthread_condattr_t</span> <span class=o>*</span><span class=n>cond_attr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cond_signal</span><span class=p>(</span><span class=kt>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cond_broadcast</span><span class=p>(</span><span class=kt>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=kt>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>,</span> <span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cond_timedwait</span><span class=p>(</span><span class=kt>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>,</span> <span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>,</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=n>abstime</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cond_destroy</span><span class=p>(</span><span class=kt>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=5-网络编程>5. 网络编程<a hidden class=anchor aria-hidden=true href=#5-网络编程>#</a></h2><h3 id=地址信息转换>地址信息转换<a hidden class=anchor aria-hidden=true href=#地址信息转换>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//man 7 ip
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>套接字二元组</span>
</span></span><span class=line><span class=cl><span class=cm>/* Internet address. */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sa_family_t</span> <span class=n>sin_family</span><span class=p>;</span> <span class=cm>/* address family: AF_INET */</span>
</span></span><span class=line><span class=cl>    <span class=kt>in_port_t</span> <span class=n>sin_port</span><span class=p>;</span> <span class=cm>/* port in network byte order */</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=cm>/* struct in_addr { uint32_t s_addr; };*/</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>in_addr</span> <span class=n>sin_addr</span><span class=p>;</span> <span class=cm>/* internet address */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=cm>/* address in network byte order */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=err>字节序转换</span>
</span></span><span class=line><span class=cl><span class=c1>//  h:host	    n:net	   l:32bit    	s:16bit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>uint32_t</span> <span class=nf>htonl</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>hostlong</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint16_t</span> <span class=nf>htons</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=n>hostshort</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>ntohl</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>netlong</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>uint16_t</span> <span class=nf>ntohs</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=n>netshort</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>将</span><span class=n>IP地址转换成文本</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>inet_ntop</span><span class=p>(</span><span class=kt>int</span> <span class=n>af</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=n>size</span><span class=p>);</span> <span class=c1>// inet_ntop - convert IPv4 and IPv6 addresses from binary to text form
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=err>网络字节序</span><span class=o>&lt;-----&gt;</span><span class=err>点分十进制相互转换</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>inet_aton</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>cp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>in_addr</span> <span class=o>*</span><span class=n>inp</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>==</span> <span class=kt>in_addr_t</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>cp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>inet_ntoa</span><span class=p>(</span><span class=k>struct</span> <span class=n>in_addr</span> <span class=n>in</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//线程安全版本是inet_atop inet_ptoa
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>获取某域名的</span><span class=n>IP相关信息</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>struct</span> <span class=n>hostent</span> <span class=o>*</span><span class=nf>gethostbyname</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span> <span class=c1>//传入参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>hostent</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>h_name</span><span class=p>;</span> <span class=cm>/* official name of host */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>**</span><span class=n>h_aliases</span><span class=p>;</span> <span class=cm>/* alias list */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>h_addrtype</span><span class=p>;</span> <span class=cm>/* host address type */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>h_length</span><span class=p>;</span> <span class=cm>/* length of address */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>**</span><span class=n>h_addr_list</span><span class=p>;</span> <span class=cm>/* list of addresses */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=套接字编程>套接字编程<a hidden class=anchor aria-hidden=true href=#套接字编程>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=err>创建套接字</span>
</span></span><span class=line><span class=cl><span class=c1>//domain AF_INET --&gt; IPv4 AF_INET6 --&gt; IPv6
</span></span></span><span class=line><span class=cl><span class=c1>//type SOCK_STREAM --&gt; TCP SOCK_DGRAM --&gt; UDP
</span></span></span><span class=line><span class=cl><span class=c1>//protocol IPPROTO_TCP --&gt; TCP IPPROTO_UDP --&gt;UDP
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>socket</span><span class=p>(</span><span class=kt>int</span> <span class=n>domain</span><span class=p>,</span> <span class=kt>int</span> <span class=n>type</span><span class=p>,</span> <span class=kt>int</span> <span class=n>protocol</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>TCP</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=err>客户端</span>
</span></span><span class=line><span class=cl>	<span class=mf>1.</span>  <span class=kt>int</span> <span class=nf>socket</span><span class=p>(</span><span class=kt>int</span> <span class=n>domain</span><span class=p>,</span> <span class=kt>int</span> <span class=n>type</span><span class=p>,</span> <span class=kt>int</span> <span class=n>protocol</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=mf>2.</span>  <span class=kt>int</span> <span class=nf>connect</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=mf>3.</span>  <span class=kt>ssize_t</span> <span class=nf>send</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=kt>ssize_t</span> <span class=nf>recv</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>服务器</span>
</span></span><span class=line><span class=cl>	<span class=mf>1.</span>  <span class=kt>int</span> <span class=nf>socket</span><span class=p>(</span><span class=kt>int</span> <span class=n>domain</span><span class=p>,</span> <span class=kt>int</span> <span class=n>type</span><span class=p>,</span> <span class=kt>int</span> <span class=n>protocol</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=mf>2.</span>  <span class=kt>int</span> <span class=nf>bind</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=kt>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=mf>3.</span>  <span class=kt>int</span> <span class=nf>listen</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>backlog</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=mf>4.</span>  <span class=kt>int</span> <span class=nf>accept</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=o>*</span><span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=mf>5.</span>  <span class=kt>ssize_t</span> <span class=nf>send</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>ssize_t</span> <span class=nf>recv</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>UDP</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>sendto</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>dest_addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>recvfrom</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>src_addr</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=o>*</span><span class=n>addrlen</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=epoll>epoll<a hidden class=anchor aria-hidden=true href=#epoll>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=mf>1.</span> <span class=err>创建</span><span class=n>epoll文件对象</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_create</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span> <span class=err>设置事件合集</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>epoll_event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>events</span><span class=p>;</span> <span class=cm>/* Epoll events */</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>epoll_data_t</span> <span class=n>data</span><span class=p>;</span> <span class=cm>/* User data variable */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*typedef union epoll_data {
</span></span></span><span class=line><span class=cl><span class=cm>            void *ptr;
</span></span></span><span class=line><span class=cl><span class=cm>            int fd;
</span></span></span><span class=line><span class=cl><span class=cm>            uint32_t u32;
</span></span></span><span class=line><span class=cl><span class=cm>            uint64_t u64;
</span></span></span><span class=line><span class=cl><span class=cm>	} epoll_data_t;*/</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_ctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>op</span><span class=p>,</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span><span class=o>*</span> <span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>3.</span> <span class=err>等待事件</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_wait</span><span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span><span class=o>*</span> <span class=n>events</span><span class=p>,</span> <span class=kt>int</span> <span class=n>maxevents</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://LinPr.github.io/tags/linux/>linux</a></li></ul><nav class=paginav><a class=prev href=https://LinPr.github.io/posts/go_http%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%A4%84%E7%90%86/><span class=title>« Prev</span><br><span>Go_Http连接建立和处理</span>
</a><a class=next href=https://LinPr.github.io/posts/fist-blog/><span class=title>Next »</span><br><span>Fist Blog</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Unix_System_Call on x" href="https://x.com/intent/tweet/?text=Unix_System_Call&amp;url=https%3a%2f%2fLinPr.github.io%2fposts%2funix_system_call%2f&amp;hashtags=linux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unix_System_Call on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fLinPr.github.io%2fposts%2funix_system_call%2f&amp;title=Unix_System_Call&amp;summary=Unix_System_Call&amp;source=https%3a%2f%2fLinPr.github.io%2fposts%2funix_system_call%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unix_System_Call on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fLinPr.github.io%2fposts%2funix_system_call%2f&title=Unix_System_Call"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unix_System_Call on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fLinPr.github.io%2fposts%2funix_system_call%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unix_System_Call on whatsapp" href="https://api.whatsapp.com/send?text=Unix_System_Call%20-%20https%3a%2f%2fLinPr.github.io%2fposts%2funix_system_call%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unix_System_Call on telegram" href="https://telegram.me/share/url?text=Unix_System_Call&amp;url=https%3a%2f%2fLinPr.github.io%2fposts%2funix_system_call%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unix_System_Call on ycombinator" href="https://news.ycombinator.com/submitlink?t=Unix_System_Call&u=https%3a%2f%2fLinPr.github.io%2fposts%2funix_system_call%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://LinPr.github.io/>Mr.LinPr Hugo Site</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>